#!/usr/bin/env bash

scriptPath="$(readlink -f ${BASH_SOURCE[0]:-$0})"
scriptDir="$(dirname "${scriptPath}")";
scriptName=${0##*/}
source "${scriptDir}/libxlvini"

fetchUpdate() {
	local scope="${scriptName}"

	if [[ $fetchUpdadeSig != 0 ]];then
		sinf "Fetching updated repo.." 
		apt update;
	fi
}

upgrade() {
	local scope="${scriptName}-pkg"

	__upgrade() { 
		echo ""
		sinf "Upgrading packages.."
		DEBIAN_FRONTEND=noninteractive apt upgrade $aptEarg && { [ "$cleanSig" -ne 1 ] && clean || return 0; }

	}
	fetchUpdate&&
	(__upgrade||(fixpkg && __upgrade;))
	fixBootLink
}

distUpgrade() {
	local scope="${scriptName}"

	upgradeSig=0
	distUpgradeSub() { 
		echo ""
		sinf "Upgrading distro.."
		DEBIAN_FRONTEND=noninteractive apt dist-upgrade $aptEarg && apt install -y linux-headers-$(uname -r) && { [ "$cleanSig" -ne 1 ] && clean || return 0; }
	}
	salrt "Perfoming system wide upgrade.."
 	fetchUpdate&&
	(distUpgradeSub||(fixpkg && distUpgradeSub;))
	fixBootLink
}

fixpkg() {
	echo ""
	local scope="${scriptName}-fix"

	sinf "Repairing any broken packages.."
	dpkg --configure -a $dpkgEarg;
	apt --fix-missing --fix-broken install $aptEarg;
	( apt-cache show linux-headers-$(uname -r) 2>/dev/null && \
	apt install -y linux-headers-$(uname -r) 2>/dev/null )
}

clean() {
	local scope="${scriptName}-clean"

	if [[ $1 == 2 ]];then
		echo ""
		sinf "Removing cache.."
		apt clean -y;
	else
		echo ""
		sinf "Removing outdated cache.."
		apt autoclean -y;
	fi
	
	apt --purge autoremove -y;
}

fixBootLink(){
	local scope="${scriptName}-boot"

	# Define the fixBoot function
	fixBoot() {
	    echo ""
	    sinf "Creating link to latest 'initrd.img, vmlinuz' in '/boot'.."
	    bootDir="$1"
	    cd ${bootDir} || exit
	    ln -svf "$(basename "$(ls -t "$bootDir"/initrd.img-* | head -n1)")" initrd.img
	    ln -svf "$(basename "$(ls -t "$bootDir"/vmlinuz-* | head -n1)")" vmlinuz
	}

	# Set bootDir
	bootDir="/boot"

	# Check if bootDir exists and contains the necessary files
	if [[ -d "$bootDir" && $(ls "$bootDir"/vmlinuz-* 2>/dev/null) && $(ls "$bootDir"/initrd.img-* 2>/dev/null) ]]; then
	    fixBoot "$bootDir"
	elif [[ "$bootDir" = "$HOME/../boot" && -d "$bootDir" && $(ls "$bootDir"/vmlinuz-* 2>/dev/null) && $(ls "$bootDir"/initrd.img-* 2>/dev/null) ]]; then
	    fixBoot "$bootDir"
	elif [[ "$bootDir" = "$HOME/../../boot" && -d "$bootDir" && $(ls "$bootDir"/vmlinuz-* 2>/dev/null) && $(ls "$bootDir"/initrd.img-* 2>/dev/null) ]]; then
	    fixBoot "$bootDir"
	else
	    echo ""
		salrt "Couldnt update links to 'vmlinuz, initrd', no '/boot' dir.."
	fi

	# Set fixBootLinkSig
	fixBootLinkSig=0
}


#--------------------FUNCTIONS-END--------------------
while getopts "xuUonfcClkh" opt;do case $opt in
# while [[ $# -gt 0 ]];do case $1 in
		x) #dont upgrade pkg
			fetchUpdadeSig=0
			upgradeSig=0
			;;
		u) #perform system upgrade
			upgradeSig=1
			;;
		U) distUpgradeSig=1
			;;

		# --force-confold: do not modify the current configuration file, the new version is installed with a .dpkg-dist suffix. With this option alone, even configuration files that you have not modified are left untouched. You need to combine it with --force-confdef to let dpkg overwrite configuration files that you have not modified.
		# --force-confnew: always install the new version of the configuration file, the current version is kept in a file with the .dpkg-old suffix.
		# --force-confdef: ask dpkg to decide alone when it can and prompt otherwise. This is the default behavior of dpkg and this option is mainly useful in combination with --force-confold.
		# --force-confmiss: ask dpkg to install the configuration file if itâ€™s currently missing (for example because you have removed the file by mistake).
		o) 	keepOldConf='-o Dpkg::Options::="--force-confdef" -o Dpkg::Options::="--force-confold"'
			dkeepOldConf='--force-confdef --force-confold"'
			;;
		n)	keepNewConf='-o Dpkg::Options::="--force-confdef" -o Dpkg::Options::="--force-confnew"'
			dkeepNewConf='--force-confdef --force-confnew"'
			;;
		f) #fix missing dependencies & reconfigure packages
			fixpkgSig=1
			;;
		c) # clean leftovers
			((cleanSig++))
			;;
		C) # clean leftovers
			cleanSig=2
			;;
		l) # fix boot link for /boot/vmlinuz & initrd.img
			fixBootLinkSig=1
			;;
		k) #kernel free
			kernFreeSig=1
			;;
		h | --help)
	        echo -e "\nBe self-dependent !!"
	        exit 0
	        ;;
	    :)
	        alert "Error: Option $1 requires an argument."
	        usage
	        exit 1
	        ;;
	    *)
	        alert "Error: Invalid option $1"
	        usage
	        exit 1
	        ;;

	esac
	# shift
done

dpkgEarg="$dkeepOldConf $dkeepNewConf"
aptEarg="-y $keepOldConf $keepNewConf"

export DEBIAN_FRONTEND=noninteractive

# main function..
[ "${@:-0}" == '-x' ] && sinf "Nothing to.." && exit 0;
[ "${distUpgradeSig:-0}" -eq 1 ] && distUpgrade;
[ "${upgradeSig:-0}" -eq 1 ] && upgrade;
[ "${kernFreeSig:-0}" -eq 1 ] && (echo ""; salrt "Removing old kernels.."; kern-free -y;)
[ "${fixpkgSig:-0}" -eq 1 ] && fixpkg;
[ "${cleanSig:-0}" -eq 1 ] && clean $cleanSig;
[ "${fixBootLinkSig:-0}" -eq 1 ] && fixBootLink;
[ "${?}" -eq 0 ] && (smsg "$(date): upgrade successful") | (salert "$(date): upgrade failed")

